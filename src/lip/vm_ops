BEGIN_OP(NOP)
END_OP(NOP)

BEGIN_OP(POP)
	++sp;
END_OP(POP)

BEGIN_OP(LDK)
	*(--sp) = fn.constants[operand];
END_OP(LDK)

BEGIN_OP(LDLV)
	*(--sp) = ep[operand];
END_OP(LDLV)

BEGIN_OP(LDCV)
	*(--sp) = fp->closure->environment[operand];
END_OP(LDCV)

BEGIN_OP(IMP)
	lip_value_t val = fn.imports[operand].value;
	if(val.type != LIP_VAL_PLACEHOLDER)
	{
		*(--sp) = val;
	}
	else
	{
		*(--sp) = (lip_value_t) {
			.type = LIP_VAL_NATIVE,
			.data = { .reference = &fn.imports[operand] }
		};
		*(--sp) = (lip_value_t) {
			.type = LIP_VAL_NATIVE,
			.data = {
				.reference = lip_function_resource(
					fp->closure->function.lip, fn.imports[operand].name
				)
			}
		};
		*(--sp) = val;
		SAVE_CONTEXT();
		++vm->fp;
		*(vm->fp) = *(vm->fp - 1);
		lip_exec_status_t status = lip_vm_do_call(vm, 2);
		if(status != LIP_EXEC_OK) { return status; }
		LOAD_CONTEXT();
	}
END_OP(IMP)

BEGIN_OP(LDI)
	lip_value_t* value = --sp;
	value->type = LIP_VAL_NUMBER;
	value->data.number = operand;
END_OP(LDI)

BEGIN_OP(LDB)
	lip_value_t* value = --sp;
	value->type = LIP_VAL_BOOLEAN;
	value->data.boolean = operand;
END_OP(LDB)

BEGIN_OP(PLHR)
	lip_value_t* value = ep + operand;
	value->type = LIP_VAL_PLACEHOLDER;
	value->data.index = operand;
END_OP(PLHR)

BEGIN_OP(NIL)
	(--sp)->type = LIP_VAL_NIL;
END_OP(NIL)

BEGIN_OP(JMP)
	pc = fn.instructions + operand;
END_OP(JMP)

BEGIN_OP(JOF)
	lip_value_t* top = (sp++);
	bool is_false =
		(top->type == LIP_VAL_NIL)
		|| (top->type == LIP_VAL_BOOLEAN && !top->data.boolean);
	lip_instruction_t* false_target = fn.instructions + operand;
	pc = is_false ? false_target : pc;
END_OP(JOF)

BEGIN_OP(CALL)
	SAVE_CONTEXT();
	++vm->fp;
	*(vm->fp) = *(vm->fp - 1);
	lip_exec_status_t status = lip_vm_do_call(vm, operand);
	if(status != LIP_EXEC_OK) { return status; }
	LOAD_CONTEXT();
END_OP(CALL)

BEGIN_OP(TAIL)
	SAVE_CONTEXT();
	vm->fp->ep = (vm->fp - 1)->ep;
	lip_exec_status_t status = lip_vm_do_call(vm, operand);
	if(status != LIP_EXEC_OK) { return status; }
	if(vm->fp->is_native) { return LIP_EXEC_OK; }
	LOAD_CONTEXT();
END_OP(TAIL)

BEGIN_OP(RET)
	SAVE_CONTEXT();
	--vm->fp;
	if(vm->fp->is_native) { return LIP_EXEC_OK; }
	LOAD_CONTEXT();
END_OP(RET)

BEGIN_OP(LT)
	lip_value_t* lhs = sp;
	lip_value_t* rhs = sp + 1;
	lip_value_t result = {
		.type = LIP_VAL_BOOLEAN,
		.data = { .boolean = lhs->data.number < rhs->data.number }
	};
	*(++sp) = result;
END_OP(LT)

BEGIN_OP(ADD)
	double acc = 0.0;
	for(int i = 0; i < operand; ++i)
	{
		acc += sp[i].data.number;
	}
	lip_value_t result = {
		.type = LIP_VAL_NUMBER,
		.data = { .number = acc }
	};
	sp += (operand - 1);
	*sp = result;
END_OP(ADD)

BEGIN_OP(CLS)
	unsigned int function_index = operand & 0xFFF;
	unsigned int num_captures = (operand >> 12) & 0xFFF;
	size_t env_size = num_captures * sizeof(lip_value_t);
	size_t closure_size = sizeof(lip_closure_t) + env_size;
	lip_closure_t* closure = lip_malloc(vm->config.allocator, closure_size);
	closure->is_native = false;
	closure->function.lip = lip_function_resource(
		fp->closure->function.lip, fn.function_offsets[function_index]
	);
	closure->env_len = num_captures;
	for(unsigned int i = 0; i < num_captures; ++i)
	{
		lip_opcode_t opcode;
		int32_t var_index;
		lip_disasm(pc[i], &opcode, &var_index);
		lip_value_t* target =
			(opcode == LIP_OP_LDLV ? ep : fp->closure->environment) + var_index;
		closure->environment[i] = *target;
	}
	pc += num_captures;
	lip_value_t value = {
		.type = LIP_VAL_FUNCTION,
		.data = { .reference = closure }
	};
	*(--sp) = value;
END_OP(CLS)

BEGIN_OP(RCLS)
	lip_value_t* target = ep + operand;
	if(target->type == LIP_VAL_FUNCTION)
	{
		lip_closure_t* closure = target->data.reference;
		for(unsigned int i = 0; i < closure->env_len; ++i)
		{
			lip_value_t* captured_val = &closure->environment[i];
			if(captured_val->type == LIP_VAL_PLACEHOLDER)
			{
				*captured_val = *(ep + captured_val->data.index);
			}
		}
	}
	else if(target->type == LIP_VAL_PLACEHOLDER)
	{
		*target = *(ep + target->data.index);
	}
END_OP(RCLS)

BEGIN_OP(SET)
	ep[operand] = *(sp++);
END_OP(SET)
